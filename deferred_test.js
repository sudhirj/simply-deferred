// Generated by CoffeeScript 1.3.1
(function() {
  var assert, assertHasPromiseApi, assertIsPromise, deferred, expectedMethods, _,
    __slice = [].slice;

  deferred = require('./deferred');

  assert = require('assert');

  _ = require('underscore');

  expectedMethods = ['done', 'fail', 'always', 'state', 'then', 'pipe'];

  assertHasPromiseApi = function(promise) {
    var method, _i, _len, _results;
    _results = [];
    for (_i = 0, _len = expectedMethods.length; _i < _len; _i++) {
      method = expectedMethods[_i];
      _results.push(assert(_.has(promise, method)));
    }
    return _results;
  };

  assertIsPromise = function(promise) {
    assert.equal(_.keys(promise).length, expectedMethods.length);
    return assertHasPromiseApi(promise);
  };

  describe('deferred', function() {
    it('should create and return a deferred object', function() {
      var def;
      def = new deferred.Deferred();
      return assert.equal(def.state(), "pending");
    });
    it('should maintain a resolved state', function() {
      var def;
      def = new deferred.Deferred();
      assert.equal(def.state(), "pending");
      def.resolve();
      assert.equal(def.state(), "resolved");
      def.resolve();
      assert.equal(def.state(), "resolved");
      def.reject();
      return assert.equal(def.state(), "resolved");
    });
    it('should maintain a rejected state', function() {
      var def;
      def = new deferred.Deferred();
      assert.equal(def.state(), "pending");
      def.reject();
      assert.equal(def.state(), "rejected");
      def.reject();
      assert.equal(def.state(), "rejected");
      def.resolve();
      return assert.equal(def.state(), "rejected");
    });
    it('should call all the done callbacks', function(done) {
      var callback, def;
      def = new deferred.Deferred();
      callback = _.after(8, done);
      def.done(callback).done([callback, callback]);
      def.resolve();
      def.done(callback, callback);
      def.reject();
      def.done(callback, [callback, callback]);
      return def.fail(callback, callback);
    });
    it('should call all the fail callbacks', function(done) {
      var callback, def;
      def = new deferred.Deferred();
      callback = _.after(8, done);
      def.fail(callback).fail([callback, callback]);
      def.reject();
      def.fail(callback, callback);
      def.resolve();
      def.fail(callback, [callback, callback]);
      return def.done(callback);
    });
    it('should call all the always callbacks on resolution', function(done) {
      var callback, def;
      def = new deferred.Deferred();
      callback = _.after(8, done);
      def.always(callback).always([callback, callback]);
      def.resolve();
      def.always(callback, callback);
      def.always(callback, [callback, callback]);
      return def.fail(callback);
    });
    it('should call the always callbacks on rejection', function(done) {
      var def;
      def = new deferred.Deferred();
      def.always(done);
      def.reject();
      return def.done(done);
    });
    it('should call callbacks with arguments', function(done) {
      var callback, finish;
      finish = _.after(8, done);
      callback = function(arg1, arg2) {
        if (arg1 === 42 && arg2 === 24) {
          return finish();
        }
      };
      new deferred.Deferred().always(callback).resolve(42, 24).always(callback);
      new deferred.Deferred().always(callback).reject(42, 24).always(callback);
      new deferred.Deferred().done(callback).resolve(42, 24).done(callback);
      return new deferred.Deferred().fail(callback).reject(42, 24).fail(callback);
    });
    it('should provide a when method', function(done) {
      var all, callback, def1, def2, def3;
      callback = _.after(4, done);
      def1 = new deferred.Deferred().done(callback);
      def2 = new deferred.Deferred().done(callback);
      def3 = new deferred.Deferred().done(callback);
      all = deferred.when(def1, def2, def3).done(callback);
      def1.resolve();
      def2.resolve();
      return def3.resolve();
    });
    describe('pipe', function() {
      it('should pipe on resolution', function(done) {
        var def, filtered, finisher;
        finisher = function(value) {
          if (value === 10) {
            return done();
          }
        };
        def = new deferred.Deferred();
        filtered = def.pipe(function(value) {
          return value * 2;
        });
        def.resolve(5);
        return filtered.done(finisher);
      });
      it('should pipe on rejection', function(done) {
        var def, filtered, finisher;
        finisher = function(value) {
          if (value === 6) {
            return done();
          }
        };
        def = new deferred.Deferred();
        filtered = def.pipe(null, function(value) {
          return value * 3;
        });
        def.reject(2);
        return filtered.fail(finisher);
      });
      it('should pass through for null filters for done', function(done) {
        var def, filtered, finisher;
        finisher = function(value) {
          if (value === 5) {
            return done();
          }
        };
        def = new deferred.Deferred();
        filtered = def.pipe(null, null);
        def.resolve(5);
        return filtered.done(finisher);
      });
      return it('should pass through for null filters for fail', function(done) {
        var def, filtered, finisher;
        finisher = function(value) {
          if (value === 5) {
            return done();
          }
        };
        def = new deferred.Deferred();
        filtered = def.pipe(null, null);
        def.reject(5);
        return filtered.fail(finisher);
      });
    });
    describe('then', function() {
      return it('should alias pipe', function() {
        var def;
        def = new deferred.Deferred();
        return assert.equal(def.then, def.pipe);
      });
    });
    describe('promises', function() {
      it('should provide a promise that has a restricted API', function(done) {
        var callback, def, promise;
        def = new deferred.Deferred();
        promise = def.promise();
        assertIsPromise(promise);
        callback = _.after(5, done);
        promise.always(callback).always(callback).fail(callback).done(callback).fail(callback);
        assertIsPromise(promise.done(callback));
        assertIsPromise(promise.fail(callback));
        assertIsPromise(promise.always(callback));
        assert("pending", promise.state());
        def.resolve();
        return assert("resolved", promise.state());
      });
      it('should create a promise out of a given object', function() {
        var candidate, def, promise;
        candidate = {
          id: 42
        };
        def = new deferred.Deferred();
        promise = def.promise(candidate);
        assert.equal(candidate, promise);
        return assertHasPromiseApi(candidate);
      });
      return describe('when', function() {
        return it('should return a promise', function() {
          return assertIsPromise(deferred.when(new deferred.Deferred()));
        });
      });
    });
    return describe('installation into a jQuery compatible library', function() {
      var exampleArgs;
      exampleArgs = [42, 24];
      it('should install .Deferred', function() {
        var zepto;
        zepto = {};
        deferred.installInto(zepto);
        return assertHasPromiseApi(zepto.Deferred());
      });
      it('should install .when', function() {
        var zepto;
        zepto = {};
        deferred.installInto(zepto);
        return assert.equal(zepto.when.toString(), deferred.when.toString());
      });
      it('should wrap .ajax()', function(done) {
        var zepto;
        zepto = {};
        zepto.ajax = function(options) {
          return done();
        };
        deferred.installInto(zepto);
        return assertIsPromise(zepto.ajax());
      });
      it('should resolve on success', function(done) {
        var callback, promise, success, zepto;
        callback = _.after(3, done);
        zepto = {};
        zepto.ajax = function(options) {
          return options.success.apply(options, exampleArgs);
        };
        deferred.installInto(zepto);
        success = function() {
          var args;
          args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
          if (args.length === exampleArgs.length) {
            return callback();
          }
        };
        promise = zepto.ajax({
          success: success
        });
        promise.done(success);
        promise.always(success);
        return promise.fail(function() {
          return fail();
        });
      });
      it('should reject on failure', function(done) {
        var callback, error, promise, zepto;
        callback = _.after(3, done);
        zepto = {};
        zepto.ajax = function(options) {
          return options.error.apply(options, exampleArgs);
        };
        deferred.installInto(zepto);
        error = function() {
          var args;
          args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
          if (args.length === exampleArgs.length) {
            return callback();
          }
        };
        promise = zepto.ajax({
          error: error
        });
        promise.fail(error);
        promise.always(error);
        return promise.done(function() {
          return fail();
        });
      });
      return it('should work when no ajax callbacks are provided', function(done) {
        var zepto;
        zepto = {};
        zepto.ajax = function(options) {
          return options.success();
        };
        deferred.installInto(zepto);
        return zepto.ajax({
          success: null
        }).done(done);
      });
    });
  });

}).call(this);
