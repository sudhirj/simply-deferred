// Generated by CoffeeScript 1.3.1

/*
Simply Deferred - v.0.1.0
(c) 2012 Sudhir Jonathan, contact.me@sudhirjonathan.com
Released under the MIT License.
*/


(function() {
  var Deferred, PENDING, REJECTED, RESOLVED, execute, flatten, _, _when;

  _ = (typeof window !== "undefined" && window !== null ? window._ : void 0) || require('underscore');

  PENDING = "pending";

  RESOLVED = "resolved";

  REJECTED = "rejected";

  flatten = _.flatten;

  execute = function(callbacks, args) {
    var callback, _i, _len, _ref, _results;
    _ref = flatten(callbacks);
    _results = [];
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      callback = _ref[_i];
      _results.push(callback.apply(null, args));
    }
    return _results;
  };

  Deferred = function() {
    var alwaysCallbacks, close, closingArguments, doneCallbacks, failCallbacks, state;
    state = PENDING;
    doneCallbacks = [];
    failCallbacks = [];
    alwaysCallbacks = [];
    closingArguments = {};
    this.promise = function(candidate) {
      var storeCallbacks;
      candidate = candidate || {};
      candidate.state = function() {
        return state;
      };
      storeCallbacks = function(shouldExecuteImmediately, holder) {
        return function() {
          if (state === PENDING) {
            holder.push.apply(holder, flatten(arguments));
          }
          if (shouldExecuteImmediately()) {
            execute(arguments, closingArguments);
          }
          return candidate;
        };
      };
      candidate.done = storeCallbacks((function() {
        return state === RESOLVED;
      }), doneCallbacks);
      candidate.fail = storeCallbacks((function() {
        return state === REJECTED;
      }), failCallbacks);
      candidate.always = storeCallbacks((function() {
        return state !== PENDING;
      }), alwaysCallbacks);
      return candidate;
    };
    this.promise(this);
    close = function(finalState, callbacks) {
      return function() {
        if (state === PENDING) {
          state = finalState;
          closingArguments = arguments;
          execute([callbacks, alwaysCallbacks], closingArguments);
        }
        return this;
      };
    };
    this.resolve = close(RESOLVED, doneCallbacks);
    this.reject = close(REJECTED, failCallbacks);
    return this;
  };

  _when = function() {
    var def, defs, finish, trigger, _i, _len;
    trigger = new Deferred();
    defs = flatten(arguments);
    finish = _.after(defs.length, trigger.resolve);
    for (_i = 0, _len = defs.length; _i < _len; _i++) {
      def = defs[_i];
      def.done(finish);
    }
    return trigger.promise();
  };

  if (typeof exports !== 'undefined') {
    exports.Deferred = function() {
      return new Deferred();
    };
    exports.when = _when;
  } else {
    this['Deferred'] = function() {
      return new Deferred();
    };
    this['Deferred']['when'] = _when;
  }

}).call(this);
